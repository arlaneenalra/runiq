#!/usr/bin/env perl

use strict;
use warnings;
use diagnostics;

use Data::Dumper;

use English qw/-no_match_vars/;

use Getopt::Long;
Getopt::Long::Configure qw/bundling/;

# State variables, annoying -- These need to exist right now
my ($uniq_key, @uniq_lines, $delimiter_type);

# Set default $OUTPUT_RECORD_SEPARATOR value
# to \n
$OUTPUT_RECORD_SEPARATOR = "\n";

# Default key_callback - match the entire line
my $key_callback = sub { $_[0] };

# Setup the output handler
my $output_handler = \&output_default;

# Filters to apply to output
my @filter_chain;

# Deal with command line options
my $options_failure = GetOptions(
    # key options 
    'ignore-case|i' => sub {
        $key_callback = \&key_ignore_case;
    },

    # filtering options
    'unique|u' => sub { # only output non-repeated lines
        push @filter_chain, \&filter_unique;
    },

    'repeated|d' => sub { # only output repeated lines
        push @filter_chain, \&filter_repeated;
    },

    # output options
    'count|c' => sub { # add in the count
        $output_handler = \&output_with_count;
    },

    'all-repeated|D:s' => sub { # output all repeated lines
        my ($name, $value) = @_;

        # make sure we have a default value
        $delimiter_type = $value ? $value : 'none';

        # we use a closure to pass in the value
        $output_handler = \&output_repeated;

        push @filter_chain, \&filter_repeated;
    },

    # Use chr(0) for input and output separators
    'zero-terminated|z' => sub {
        $INPUT_RECORD_SEPARATOR = $OUTPUT_RECORD_SEPARATOR = chr(0);
    }
);

#open(my $fh, '<', 't/data/fuzzdata')
open(STDIN, '<', 't/data/lastline_test')
    or die "Unable to open data file";

# Force binary mode on IO 
binmode STDIN;
binmode STDOUT;

# Processing loop

while (1) {
    my @lines = uniq_read(*STDIN, $key_callback);

    # Are we on the last block?
    last
        if(scalar(@lines) == 0);

    # Apply filters, skip if any of the
    # filters return false, skip this line
    if(!apply_filters(\@lines, \@filter_chain)) {
        next;
    }

    # Do output
    #print Dumper(\@lines);
    $output_handler->(\@lines);
}

close(STDIN);



# Output Usage and Exit, I borrowed this f
sub usage {

    print "Working on this";

    exit(0);
}

# Default output handler
sub output_default {
    my ($lines) = @_;

    # Output first matched line
    print $lines->[0];
}

# Display count with output
sub output_with_count {
    my ($lines) = @_;

    # Use sprintf so that print works right
    my $output_line = sprintf "%7i %s", scalar(@{$lines}), $lines->[0];

    print $output_line;
}

# Output Handler for delimited output
sub output_repeated {
    my ($lines) = @_;

    # handle delimiter types
    if($delimiter_type eq 'separate') {
        # no delimiter on first group,
        # but we do have one on future
        # groups
        $delimiter_type = 'prepend';
    } elsif($delimiter_type eq 'prepend') {
        print '';
    }

    # output each line
    foreach my $line ( @{$lines}) {
        print $lines->[0];
    }
}

# Key Handler that identifies case
sub key_ignore_case {
    my ($line) = @_;

    return lc $line;
};

# Filter to only display unique lines
sub filter_unique {
    my ($lines) = @_;

    return (scalar(@{$lines}) == 1);
}

# Filter to only display repeated lines
sub filter_repeated {
    my ($lines) = @_;

    return (scalar(@{$lines}) > 1);
};

#
# Process the given line through a chain of filters
# if any of the filters return false, return false
# otherwise return true.
#
# my $result = apply_filters(\@lines, \@filters);
#
sub apply_filters {
    my ($lines, $filter_chain) = @_;

    # Teast each filter in turn
    for my $filter (@{$filter_chain}) {
        if (!$filter->($lines)) {
            return 0;
        }
    }

    return 1;
}

#
# Reads a lines from a file handle return a line
# and the number of times the line is repeated. It will
# read until there are no repititions and then returns.
# On EOF it returns @lines = ()
#
# my @lines = uniq_read($fh, $key_callback);
#

sub uniq_read {
    my ($fh, $key_callback) = @_;

    # We are at eof and have dealt with any end runs
    return ()
        if(eof($fh) && !defined($uniq_key));

    while(defined(my $new_line = <$fh>)) {

        chomp($new_line);

        # extract the key
        my $key = $key_callback->($new_line);

        # Save this off before we update
        # the global state.
        my $prev_uniq_key = $uniq_key;

        # Update global state
        $uniq_key = $key;

        # Do the uniquness
        if(defined($prev_uniq_key) && $key ne $prev_uniq_key) {

            # Save off lines and reset for next
            # line to check
            my @lines = @uniq_lines;
            @uniq_lines = ();

            push @uniq_lines, $new_line;

            return @lines;
        }

        push @uniq_lines, $new_line;
    }

    # Clear the key to that the eof test
    # at the top catches on the next call
    $uniq_key = undef;

    # We shouldn't get here unless we have eof
    return @uniq_lines;
}
