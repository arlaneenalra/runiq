#!/usr/bin/env perl

use strict;
use warnings;
use diagnostics;

use Data::Dumper;

use Getopt::Long;
Getopt::Long::Configure qw/bundling/;

# State variables, annoying -- These need to exist right now
my ($uniq_key, @uniq_lines);

# default key_callback - match the entire line
my $key_callback = sub { $_[0] };

# filters to apply to output
my @filter_chain;

# Deal with command line options
my $options_failure = GetOptions(
    # key options 
    'ignore-case|i' => sub {
        $key_callback = sub {
            my ($line) = @_;

            return lc $line;
        };
    },

    # filtering options
    'unique|u' => sub {
        push @filter_chain,sub {
            my ($lines) = @_;

            return (scalar(@{$lines}) == 1);
        };
    },

    'repeated|d' => sub {
        push @filter_chain,sub {
            my ($lines) = @_;

            return (scalar(@{$lines}) > 1);
        };
    },

    # output options
);

#open(my $fh, '<', 't/data/fuzzdata')
open(my $fh, '<', 't/data/lastline_test')
    or die "Unable to open data file";

# Processing loop

while (1) {
    my @lines = uniq_read($fh, $key_callback);

    # Are we on the last block?
    last
        if(scalar(@lines) == 0);

    # Apply filters, skip if any of the
    # filters return false, skip this line
    if(!apply_filters(\@lines, \@filter_chain)) {
        next;
    }

    print Dumper(\@lines);
}

close($fh);


# Output Usage and Exit, I borrowed this f
sub usage {

    print "Working on this$/";

    exit(0);
}

# Process the given line through a chain of filters
# if any of the filters return false, return false
# otherwise return true
sub apply_filters {
    my ($lines, $filter_chain) = @_;

    for my $filter (@{$filter_chain}) {
        if (!$filter->($lines)) {
            return 0;
        }
    }

    return 1;
}

#
# Reads a lines from a file handle return a line
# and the number of times the line is repeated. It will
# read until there are no repititions and then returns.
# On EOF it returns @lines = ()
#
# my @lines = uniq_read($fh, $key_callback);
#

sub uniq_read {
    my ($fh, $key_callback) = @_;

    # We are at eof and have dealt with any end runs
    return ()
        if(eof($fh) && !defined($uniq_key));

    while(defined(my $new_line = <$fh>)) {

        chomp($new_line);

        # extract the key
        my $key = $key_callback->($new_line);

        # Save this off before we update
        # the global state.
        my $prev_uniq_key = $uniq_key;

        # Update global state
        $uniq_key = $key;

        # Do the uniquness
        if(defined($prev_uniq_key) && $key ne $prev_uniq_key) {

            # Save off lines and reset for next
            # line to check
            my @lines = @uniq_lines;
            @uniq_lines = ();

            push @uniq_lines, $new_line;

            return @lines;
        }

        push @uniq_lines, $new_line;
    }

    # Clear the key to that the eof test
    # at the top catches on the next call
    $uniq_key = undef;

    # We shouldn't get here unless we have eof
    return @uniq_lines;
}
