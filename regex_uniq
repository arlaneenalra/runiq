#!/usr/bin/env perl

use strict;
use warnings;
use diagnostics;

use Getopt::Long;
Getopt::Long::Configure qw/bundling/;

# State variables, annoying -- These need to exist right now
my ($uniq_key, $uniq_line);

# default key_callback - match the entire line
my $key_callback = sub { $_[0] };

# filters to apply to output
my @filter_chain;

# Deal with command line options
my $options_failure = GetOptions(
    # key options 
    'ignore-case|i' => sub {
        $key_callback = sub {
            my ($line) = @_;
            return lc $line;
        };
    },

    # filtering options
    'unique|u' => sub {
        push @filter_chain,sub {
            my ($line, $count) = @_;
            return ($count == 1);
        };
    },
    'repeated|d' => sub {
        push @filter_chain,sub {
            my ($line, $count) = @_;
            return ($count > 1);
        };
    },

    # output options
);

#open(my $fh, '<', 't/data/fuzzdata')
open(my $fh, '<', 't/data/lastline_test')
    or die "Unable to open data file";

# Processing loop
my ($line, $count) = (undef, 1);

PROC_LOOP: while (1) {
    ($line, $count) = uniq_read($fh, $key_callback);

    # Are we on the last block?
    last
        if(!$count);

    # Apply filters, 
    for my $filter (@filter_chain) {
        if(!$filter->($line, $count)) {
            next PROC_LOOP;
        }
    }

    print "$count $line$/";
}

close($fh);


# Output Usage and Exit, I borrowed this f
sub usage {

    print "Working on this$/";

    exit(0);
}

#
# Reads a lines from a file handle return a line
# and the number of times the line is repeated. It will
# read until there are no repititions and then returns.
# On EOF it returns $count = 0
#
# my ($line, $count) = uniq_read($fh, $key_callback);
#

sub uniq_read {
    my ($fh, $key_callback) = @_;

    # We are at eof and have dealt with any end runs
    return '', 0
        if(eof($fh) && !defined($uniq_key));

    # the defined check handles the intial count
    my $count = defined($uniq_line) ? 0 : -1;

    while(defined(my $new_line = <$fh>)) {

        chomp($new_line);

        # extract the key
        my $key = $key_callback->($new_line);

        # Save this off before we update
        # the global state.

        my $prev_line = $uniq_line;
        my $prev_uniq_key = $uniq_key;

        # Update global state
        $uniq_key = $key;
        $uniq_line = $new_line;

        $count++;

        # Deal with first iterations
        next
            if(!defined($prev_uniq_key));

        # Do the uniquness
        return $prev_line, $count
            if(!defined($prev_uniq_key) || $key ne $prev_uniq_key);
    }

    # Update count
    $count++;

    # Clear the key to that the eof test
    # at the top catches on the next call
    $uniq_key = undef;

    # We shouldn't get here unless we have eof
    return $uniq_line, $count;
}
